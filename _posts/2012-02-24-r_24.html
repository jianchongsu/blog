--- 
layout: post
name: r_24
title: "R\xE8\xAF\xAD\xE8\xA8\x80\xE7\xBC\x96\xE7\xA8\x8B\xE5\x85\xA5\xE9\x97\xA8\xE4\xB9\x8B\xE4\xBA\x8C\xEF\xBC\x9A\xE5\xAF\xB9\xE8\xB1\xA1\xE5\x92\x8C\xE7\xB1\xBB"
date: 2012-02-24 10:42:00 +08:00
categories: 
- "\xE7\xBC\x96\xE7\xA8\x8B"
- "\xE5\x85\xA5\xE9\x97\xA8\xE6\x95\x99\xE7\xA8\x8B"
permalink: /2012/02/r_24.html
---
<div class="separator" style="clear: both; text-align: center;"><a href="http://thumbsnap.com/i/lTXf4gBN.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><br /><img border="0" height="200" src="http://thumbsnap.com/i/lTXf4gBN.jpg" width="197" /></a></div>R是一种基于<b>对象(Object)</b>的语言，所以你在R语言中接触到的每样东西都是一个对象，一串数值向量是一个对象，一个函数是一个对象，一个图形也是一个对象。基于对象的编程(OOP)就是在定义类的基础上，创建与操作对象。<br /><br />对象中包含了我们需要的数据，同时对象也具有很多<b>属性(Attribute)</b>。其中一种重要的属性就是它的<b>类(Class)</b>，R语言中最为基本的类包括了数值(numeric)、逻辑(logical)、字符(character)、列表(list)，在此基础上构成了一些复合型的类，包括矩阵(matrix)、数组(array)、因子(factor)、数据框(dataframe)。除了这些内置的类外还有很多其它的，用户还可以自定义新的类，但所有的类都是建立在这些基本的类之上的。<br /><a name='more'></a><br />我们下面来用一个简单线性回归的例子来了解一下对象和类的处理。<br /><div style="overflow: auto;"><div class="geshifilter"><pre class="r geshifilter-R"><span style="font-family: 'Courier New', Courier, monospace;"><span style="color: #666666; font-style: italic;"># 创建两个数值向量</span><br />x &lt;- <a href="http://inside-r.org/r-doc/stats/runif"><span style="color: #003399;">runif</span></a><span style="color: #009900;">(</span><span style="color: #cc66cc;">100</span><span style="color: #009900;">)</span> <br />y &lt;- <a href="http://inside-r.org/r-doc/stats/rnorm"><span style="color: #003399;">rnorm</span></a><span style="color: #009900;">(</span><span style="color: #cc66cc;">100</span><span style="color: #009900;">)</span>+<span style="color: #cc66cc;">5</span>*x<br /><span style="color: #666666; font-style: italic;"># 用线性回归创建模型，存入对象model</span><br />model &lt;- <a href="http://inside-r.org/r-doc/stats/lm"><span style="color: #003399;">lm</span></a><span style="color: #009900;">(</span>y~x<span style="color: #009900;">)</span></span></pre></div></div>好了，现在我们手头上有一个不熟悉的对象model，那么首先来看看它里面藏着什么好东西。最有用的函数命令就是<b>attributes(model)</b>，用来提取对象的各种属性，结果如下：<br /><br />&gt; attributes(model)<br />$names<br />&nbsp;[1] "coefficients" &nbsp;"residuals" &nbsp; &nbsp; "effects" &nbsp; &nbsp; <br />&nbsp;[4] "rank" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"fitted.values" "assign" &nbsp; &nbsp; <br />&nbsp;[7] "qr" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"df.residual" &nbsp; "xlevels" &nbsp; &nbsp; <br />[10] "call" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"terms" &nbsp; &nbsp; &nbsp; &nbsp; "model" &nbsp; &nbsp; &nbsp; <br /><br />$class<br />[1] "lm"<br /><br />可以看到这个对象的类是“lm”，这意味着什么呢？我们知道对于不同的类有不同的处理方法，那么对于modle这个对象，就有专门用来处理lm类对象的函数，例如plot.lm()。但如果你用普通的函数plot()也一样能显示其图形，Why？因为plot()这种函数会自动识别对象的类，从而选择合适的函数来对付它，这种函数就称为<b>泛型函数（generic function）</b>。你可以用<b>methods(class=lm)</b>来了解有哪些函数可适用于lm对象。<br /><br />好了，我们已经知道了model的底细了，你还想知道x的信息吧。如果运行attributes(x)，会发现返回了空值。这是因为x是一个向量，对于向量这种内置的基本类，attributes是没有什么好显示的。此时你可以运行<b>mode(x)</b>，可观察到向量的类是数值型。如果运行mode(model)会有什么反应呢？它会显示lm类的基本构成是由list组成的。当然要了解对象的类，也可以直接用<b>class()</b>，如果要消除对象的类则可用<b>unclass()</b>。<br /><br />从上面的结果我们还看到names这个属性，这如同你到一家餐厅问服务生要一份菜单，输入<b>names(model)</b>就相当于问model这个对象：Hi，你能提供什么好东西吗？如果你熟悉回归理论的话，就可以从names里头看到它提供了丰富的回归结果，包括回归系数（coefficients）、残差（residuals）等等，调用这些信息可以就象处理普通的数据框一样使用$符号，例如输出残差可以用model$residuals。当然用泛型函数可以达到同样的效果，如residuals(model)，但在个别情况下，这二者结果是有少许差别的。<br /><br />我们已经知道了attributes的威力了，那么另外一个非常有用的函数是<b>str()</b>，它能以简洁的方式显示对象的数据结构及其内容，试试看，非常有用的。
