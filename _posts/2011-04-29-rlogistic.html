--- 
layout: post
name: rlogistic
title: "R\xE8\xAF\xAD\xE8\xA8\x80\xE4\xB8\xAD\xE8\xBF\x9B\xE8\xA1\x8Clogistic\xE5\x9B\x9E\xE5\xBD\x92"
date: 2011-04-29 10:58:00 +08:00
categories: 
- "logistic\xE5\x9B\x9E\xE5\xBD\x92"
- "ROC\xE5\x9B\xBE"
permalink: /2011/04/rlogistic.html
---
<b>logistic回归</b>又主要在流行病学中应用较多，比较常用的情形是探索某疾病的危险因素，根据危险因素预测某疾病发生的概率，等等。例如，想探讨胃癌发生的危险因素，可以选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群肯定有不同的体征和生活方式等。这里的因变量就是是否胃癌，即“是”或“否”，为两分类变量，自变量就可以包括很多了，例如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。通过logistic回归分析，就可以大致了解到底哪些因素是胃癌的危险因素。<br /><br />logistic回归的因变量可以是二分类的，也可以是多分类的，但是二分类的更为常用，也更加容易解释。所以实际中最为常用的就是二分类的logistic回归。<br /><a name='more'></a><br /><br />在R语言中，进行logistic回归的命令是通过广义线性模型进行的：fm &lt;- glm(formula, family = binomial(link = logit),data=data.frame) ，下面以《统计建模与R软件》中的一个例子来说明用法。<br /><br />如有50位病人，其中自变量有三项生理指标分别为x1,x2,x3。因变量y是二分变量，表示为生存时间是否在1年以上。数据和代码如下：<br /><br />#首先将这四个变量建构一个数据框，取名为life<br />life = data.frame(<br />&nbsp;&nbsp; X1=c(2.5, 173, 119, 10, 502, 4, 14.4, 2, 40, 6.6,21.4, 2.8, 2.5, 6, 3.5, 62.2, 10.8, 21.6, 2, 3.4,5.1, 2.4, 1.7, 1.1, 12.8, 1.2, 3.5, 39.7, 62.4, 2.4,34.7, 28.4, 0.9, 30.6, 5.8, 6.1, 2.7, 4.7, 128, 35,2, 8.5, 2, 2, 4.3, 244.8, 4, 5.1, 32, 1.4),<br />&nbsp;&nbsp; X2=rep(c(0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,0, 2, 0, 2, 0, 2, 0),<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c(1, 4, 2, 2, 1, 1, 8, 1, 5, 1, 5, 1, 1, 1, 2, 1,1, 1, 3, 1, 2, 1, 4)),<br />&nbsp;&nbsp; X3=rep(c(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1),<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c(6, 1, 3, 1, 3, 1, 1, 5, 1, 3, 7, 1, 1, 3, 1, 1, 2, 9)),<br />&nbsp;&nbsp; Y=rep(c(0, &nbsp;1, &nbsp; 0, &nbsp;1), c(15, 10, 15, 10))<br />)<br /><br />#然后获得一般线性模型结果<br /><blockquote>glm.sol&lt;-glm(Y~X1+X2+X3, family=binomial, data=life)<br />summary(glm.sol)</blockquote><br />#根据模型对某个具体病人做预测，得到其存活一年以上概率<br /><blockquote>pre&lt;-predict(glm.sol, data.frame(X1=5,X2=2,X3=1))<br />p&lt;-exp(pre)/(1+exp(pre))</blockquote>若要检测模型预测能力，可以利用ROC图来进行观察<br />首先用原数据代入模型得出预测概率，严格来讲训练和检测需要用不同的样本，这里暂时不考虑。<br /><blockquote>pre=predict(glm.sol,type='response')</blockquote>再利用<b>ROCR包</b>绘制ROC图以衡量模型的效果。<br /><blockquote>library(ROCR)<br />m=prediction(pre,life$Y)<br />plot(performance(m,'tpr','fpr'))<br />abline(0,1, lty = 8, col = "grey")<a href="http://2.bp.blogspot.com/-zMHFDrl1_cw/Tpei3-4HkeI/AAAAAAAAAeI/PyBreEw1x_E/s1600/Rplot.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em; text-align: center;"><img border="0" src="http://2.bp.blogspot.com/-zMHFDrl1_cw/Tpei3-4HkeI/AAAAAAAAAeI/PyBreEw1x_E/s1600/Rplot.jpeg" /></a></blockquote>另一个相关的衡量标准就是ROC图的曲线下面积，许多的数据挖掘大赛会用它来作为最终的评价指标，本例的auc得出是0.85<br /><blockquote>auc &lt;- performance(m, "auc")</blockquote>
